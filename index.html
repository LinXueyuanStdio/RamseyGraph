<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ramsey Graph Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Fraunces:opsz,wght@9..144,300;9..144,600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --border-color: #2a2a2a;
            --text-primary: #e8e8e8;
            --text-secondary: #888888;
            --accent-red: #ff3366;
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --mono: 'JetBrains Mono', monospace;
            --serif: 'Fraunces', serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--mono);
            font-size: 13px;
            display: flex;
            flex-direction: column;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(255, 51, 102, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 51, 102, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
            animation: gridPulse 8s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .app {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px 24px;
            gap: 12px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .title-area {
            display: flex;
            align-items: baseline;
            gap: 16px;
        }

        h1 {
            font-family: var(--serif);
            font-size: 28px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--text-primary), var(--accent-red));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: var(--mono);
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .btn-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .lang-toggle {
            display: flex;
            gap: 4px;
        }

        .lang-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: var(--mono);
            transition: all 0.2s ease;
        }

        .lang-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        .lang-btn.active {
            border-color: var(--accent-blue);
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .lang-btn:hover:not(.active) {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .challenge-btn {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }

        .challenge-btn:hover {
            background: var(--accent-green) !important;
            color: var(--bg-primary) !important;
        }

        .main-content {
            display: flex;
            gap: 16px;
            flex: 1;
            min-height: 0;
        }

        .sidebar {
            width: 280px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 16px;
        }

        .panel-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent-red);
        }

        .selector-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .selector-item label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        select {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px;
            font-family: var(--mono);
            font-size: 13px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--accent-red);
        }

        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn {
            width: 100%;
            padding: 10px;
            font-family: var(--mono);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover:not(:disabled) {
            border-color: var(--accent-red);
            background: var(--accent-red);
            color: var(--bg-primary);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary {
            border-color: var(--accent-red);
            background: rgba(255, 51, 102, 0.1);
        }

        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        input[type="text"] {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 10px;
            font-family: var(--mono);
            font-size: 12px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-red);
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: block;
            padding: 10px;
            text-align: center;
            border: 1px dashed var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .file-label:hover {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .file-label.has-file {
            border-style: solid;
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .divider {
            text-align: center;
            color: var(--text-secondary);
            font-size: 10px;
            margin: 8px 0;
            position: relative;
        }

        .divider::before, .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: var(--border-color);
        }

        .divider::before { left: 0; }
        .divider::after { right: 0; }

        .status {
            padding: 8px 10px;
            font-size: 11px;
            border-left: 3px solid var(--accent-blue);
            background: rgba(0, 212, 255, 0.05);
            display: none;
        }

        .status.show { display: block; }
        .status.error {
            border-color: var(--accent-red);
            background: rgba(255, 51, 102, 0.05);
            color: var(--accent-red);
        }
        .status.success {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
            color: var(--accent-green);
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            min-width: 0;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .graph-info {
            display: flex;
            gap: 20px;
        }

        .info-item {
            text-align: center;
        }

        .info-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-red);
        }

        .info-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .toggle-group {
            display: flex;
            gap: 4px;
        }

        .toggle-btn {
            padding: 6px 12px;
            font-size: 10px;
            text-transform: uppercase;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: var(--mono);
        }

        .toggle-btn.active {
            border-color: var(--accent-red);
            background: var(--accent-red);
            color: var(--bg-primary);
        }

        .toggle-btn:hover:not(.active) {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        #canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas svg {
            width: 100%;
            height: 100%;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 48px;
            opacity: 0.3;
            margin-bottom: 8px;
            font-family: var(--serif);
        }

        .pagination {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .pagination button {
            padding: 6px 12px;
            font-family: var(--mono);
            font-size: 11px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .pagination button:hover:not(:disabled) {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .pagination button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .page-info {
            min-width: 100px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .page-info span {
            color: var(--accent-red);
            font-weight: 700;
        }

        .node { cursor: pointer; }
        .node:hover { filter: brightness(1.3); }
        .link { stroke-opacity: 0.6; }
        .node-label {
            font-family: var(--mono);
            font-size: 10px;
            fill: var(--text-primary);
            text-anchor: middle;
            pointer-events: none;
        }

        .legend {
            display: flex;
            gap: 16px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.red { background: var(--accent-red); }
        .legend-dot.blue { background: var(--accent-blue); }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-secondary);
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-red);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Matrix styles */
        .matrix-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            padding: 20px;
        }

        .matrix-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .matrix-labels-top {
            display: flex;
            margin-left: 30px;
        }

        .matrix-label {
            width: var(--cell-size, 24px);
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .matrix-row {
            display: flex;
            align-items: center;
        }

        .matrix-row-label {
            width: 30px;
            height: var(--cell-size, 24px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .matrix-cell {
            width: var(--cell-size, 24px);
            height: var(--cell-size, 24px);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.15s ease;
        }

        .matrix-cell.edge {
            background: var(--accent-red);
            color: var(--bg-primary);
            font-weight: 700;
        }

        .matrix-cell.complement {
            background: var(--accent-blue);
            color: var(--bg-primary);
            font-weight: 700;
        }

        .matrix-cell.diagonal {
            background: var(--bg-primary);
            color: var(--text-secondary);
        }

        .matrix-cell.empty {
            background: transparent;
            color: var(--text-secondary);
        }

        .matrix-cell:hover:not(.diagonal) {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            position: relative;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            display: flex;
            flex-direction: column;
        }

        .modal-content.modal-large {
            max-width: 900px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h2 {
            font-family: var(--serif);
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .modal-body p {
            margin-bottom: 12px;
        }

        .modal-body strong {
            color: var(--text-primary);
        }

        .modal-body .highlight {
            color: var(--accent-red);
            font-weight: 700;
        }

        .modal-body .challenge {
            padding: 16px;
            margin: 16px 0;
            background: rgba(255, 51, 102, 0.1);
            border-left: 3px solid var(--accent-red);
        }

        .modal-body .significance {
            padding: 16px;
            margin: 16px 0;
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--accent-blue);
        }

        /* Progress table */
        .ramsey-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 12px;
        }

        .ramsey-table th,
        .ramsey-table td {
            padding: 8px 6px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .ramsey-table th {
            background: var(--bg-primary);
            color: var(--accent-red);
            font-weight: 700;
        }

        .ramsey-table td.exact {
            background: rgba(0, 255, 136, 0.1);
            color: var(--accent-green);
        }

        .ramsey-table td.range {
            background: rgba(0, 212, 255, 0.1);
            color: var(--accent-blue);
        }

        .ramsey-table td.trivial {
            color: var(--text-secondary);
        }

        .table-legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            font-size: 11px;
        }

        .table-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 16px;
            height: 16px;
        }

        .legend-box.exact {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
        }

        .legend-box.range {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--accent-blue);
        }

        /* Links panel */
        .panel-links {
            margin-top: auto;
        }

        .link-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .link-list a {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .link-list a:hover {
            border-color: var(--accent-red);
            color: var(--text-primary);
        }

        .link-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--border-color);
            color: var(--text-primary);
            flex-shrink: 0;
            padding: 5px;
        }

        .link-icon svg {
            width: 100%;
            height: 100%;
        }

        .link-list a:hover .link-icon {
            background: var(--accent-red);
            color: var(--bg-primary);
        }

        .link-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Challenge Mode Styles */
        .challenge-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
            flex-direction: column;
        }

        .challenge-mode.show {
            display: flex;
        }

        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .challenge-title {
            font-family: var(--serif);
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .challenge-params {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .challenge-params select {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 60px;
        }

        .challenge-params label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .challenge-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .challenge-actions .btn,
        .challenge-params .btn {
            width: auto;
            white-space: nowrap;
        }

        .challenge-main {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .challenge-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            min-width: 0;
        }

        .challenge-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .challenge-panel-header {
            padding: 10px 16px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .challenge-canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .challenge-canvas svg {
            width: 100%;
            height: 100%;
        }

        .challenge-matrix-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .challenge-matrix-cell {
            width: var(--cell-size, 20px);
            height: var(--cell-size, 20px);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.1s ease;
            user-select: none;
        }

        .challenge-matrix-cell:hover:not(.diagonal) {
            transform: scale(1.15);
            z-index: 10;
            box-shadow: 0 0 12px rgba(255, 51, 102, 0.6);
        }

        .challenge-matrix-cell.edge {
            background: var(--accent-red);
            color: var(--bg-primary);
        }

        .challenge-matrix-cell.no-edge {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .challenge-matrix-cell.diagonal {
            background: var(--bg-primary);
            color: var(--text-secondary);
            cursor: default;
        }

        .challenge-matrix-cell.highlight-clique {
            box-shadow: 0 0 0 2px var(--accent-red), 0 0 15px var(--accent-red);
            z-index: 20;
        }

        .challenge-matrix-cell.highlight-indep {
            box-shadow: 0 0 0 2px var(--accent-blue), 0 0 15px var(--accent-blue);
            z-index: 20;
        }

        .challenge-status {
            padding: 12px 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-indicator.ok {
            background: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
        }

        .status-indicator.warning {
            background: var(--accent-red);
            box-shadow: 0 0 8px var(--accent-red);
            animation: pulse-warning 1s ease-in-out infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .found-structures {
            display: flex;
            gap: 16px;
        }

        .structure-badge {
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 2px;
        }

        .structure-badge.clique {
            background: rgba(255, 51, 102, 0.2);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
        }

        .structure-badge.indep {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
        }

        .challenge-node {
            cursor: pointer;
        }

        .challenge-node:hover {
            filter: brightness(1.3);
        }

        .challenge-node.highlight-clique {
            fill: var(--accent-red) !important;
            filter: url(#double-border);
        }

        .challenge-node.highlight-indep {
            fill: var(--accent-blue) !important;
            filter: url(#double-border);
        }

        /* Node in both clique and independent set - half red, half blue */
        .challenge-node.highlight-both {
            fill: url(#gradient-both) !important;
            filter: url(#double-border);
        }

        .challenge-link.highlight-clique {
            stroke: var(--accent-red) !important;
            stroke-width: 4px !important;
            stroke-opacity: 1 !important;
        }

        .challenge-link.highlight-indep {
            stroke: var(--accent-blue) !important;
            stroke-width: 4px !important;
            stroke-opacity: 1 !important;
            stroke-dasharray: 5,5;
        }

        /* Success celebration */
        .success-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .success-overlay.show {
            display: flex;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .success-content {
            text-align: center;
            padding: 40px;
        }

        .success-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .success-title {
            font-family: var(--serif);
            font-size: 32px;
            color: var(--accent-green);
            margin-bottom: 12px;
        }

        .success-message {
            font-size: 14px;
            color: var(--text-secondary);
            max-width: 400px;
            line-height: 1.6;
        }

        .import-select {
            min-width: 120px;
        }

        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }
            .sidebar .panel {
                flex: 1;
                min-width: 200px;
            }
            .panel-links {
                margin-top: 0;
            }
            .canvas-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .challenge-header {
                flex-direction: column;
                gap: 12px;
            }
            .challenge-title {
                flex-direction: column;
                gap: 8px;
            }
            .challenge-main {
                flex-direction: column;
            }
            .challenge-left {
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                min-height: 300px;
            }
            .challenge-right {
                min-height: 300px;
            }
            .challenge-status {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="title-area">
                <h1>Ramsey Graph</h1>
                <span class="subtitle" data-i18n="subtitle">Interactive Visualizer</span>
            </div>
            <div class="header-actions">
                <button class="action-btn" id="introBtn">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                    <span data-i18n="introduction">Introduction</span>
                </button>
                <button class="action-btn" id="progressBtn">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 20V10"></path>
                        <path d="M12 20V4"></path>
                        <path d="M6 20v-6"></path>
                    </svg>
                    <span data-i18n="progress">Progress</span>
                </button>
                <button class="action-btn challenge-btn" id="challengeBtn">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                        <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                        <path d="M4 22h16"></path>
                        <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                        <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                        <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
                    </svg>
                    <span data-i18n="challenge">Challenge</span>
                </button>
                <div class="lang-toggle">
                    <button class="lang-btn active" data-lang="en">
                        <svg class="lang-icon" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="1.5"/>
                            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" fill="none" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                        EN
                    </button>
                    <button class="lang-btn" data-lang="zh">
                        <svg class="lang-icon" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="1.5"/>
                            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" fill="none" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                        ‰∏≠Êñá
                    </button>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="sidebar">
                <div class="panel">
                    <div class="panel-title" data-i18n="selectDataset">Select Dataset</div>
                    <div class="selector-grid">
                        <div class="selector-item">
                            <label>s</label>
                            <select id="selectS"></select>
                        </div>
                        <div class="selector-item">
                            <label>t</label>
                            <select id="selectT"></select>
                        </div>
                        <div class="selector-item">
                            <label>n</label>
                            <select id="selectN"></select>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="loadDatasetBtn" data-i18n="loadDataset">Load Ramsey(s,t,n)</button>
                    <div id="datasetInfo" style="margin-top: 8px; font-size: 10px; color: var(--text-secondary);"></div>
                </div>

                <div class="panel">
                    <div class="panel-title" data-i18n="customSource">Custom Source</div>
                    <div class="input-row">
                        <input type="text" id="urlInput" data-i18n-placeholder="urlPlaceholder" placeholder="Enter .g6 file URL...">
                    </div>
                    <button class="btn" id="loadUrlBtn" data-i18n="loadUrl">Load URL</button>
                    <div class="divider" data-i18n="or">or</div>
                    <input type="file" id="fileInput" accept=".g6">
                    <label class="file-label" id="fileLabel" for="fileInput" data-i18n="uploadFile">
                        Drop or click to upload .g6 file
                    </label>
                </div>

                <div id="status" class="status"></div>

                <div class="panel panel-links">
                    <div class="panel-title" data-i18n="links">Links</div>
                    <div class="link-list">
                        <a href="https://huggingface.co/datasets/linxy/RamseyGraph" target="_blank">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="hfDataset">HuggingFace Dataset</span>
                        </a>
                        <a href="https://github.com/LinXueyuanStdio/RamseyGraph" target="_blank">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="ghRepo">GitHub Repository</span>
                        </a>
                        <a href="https://users.cecs.anu.edu.au/~bdm/data/ramsey.html" target="_blank">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                                    <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                                    <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="originDb">Origin Database</span>
                        </a>
                        <a href="mailto:linxy59@mail2.sysu.edu.cn">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                                    <polyline points="22,6 12,13 2,6"></polyline>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="contact">Contact</span>
                        </a>
                        <a href="https://www.combinatorics.org" target="_blank">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="wiki">E-JC Survey</span>
                        </a>
                        <a href="https://en.wikipedia.org/wiki/Ramsey%27s_theorem" target="_blank" id="wikiLink">
                            <span class="link-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 16v-4"></path>
                                    <path d="M12 8h.01"></path>
                                </svg>
                            </span>
                            <span class="link-text" data-i18n="wikiLink">Wikipedia</span>
                        </a>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <div class="canvas-header">
                    <div class="header-left">
                        <div class="graph-info">
                            <div class="info-item">
                                <div class="info-value" id="nodeCount">-</div>
                                <div class="info-label" data-i18n="nodes">Nodes</div>
                            </div>
                            <div class="info-item">
                                <div class="info-value" id="edgeCount">-</div>
                                <div class="info-label" data-i18n="edges">Edges</div>
                            </div>
                        </div>
                        <div class="legend">
                            <div class="legend-item"><div class="legend-dot red"></div><span data-i18n="graphG">Graph G</span></div>
                            <div class="legend-item"><div class="legend-dot blue"></div><span data-i18n="complement">Complement</span></div>
                        </div>
                    </div>
                    <div class="header-right">
                        <div class="toggle-group" id="displayToggle">
                            <button class="toggle-btn active" data-display="force" data-i18n="force">Force</button>
                            <button class="toggle-btn" data-display="matrix" data-i18n="matrix">Matrix</button>
                        </div>
                        <div class="toggle-group" id="viewToggle">
                            <button class="toggle-btn active" data-mode="graph">G</button>
                            <button class="toggle-btn" data-mode="complement">G'</button>
                            <button class="toggle-btn" data-mode="both" data-i18n="both">Both</button>
                        </div>
                        <button class="btn" id="openChallengeWithGraph" style="padding: 6px 12px; width: auto; display: none;" data-i18n="editInChallenge">Edit in Challenge</button>
                    </div>
                </div>
                <div id="canvas">
                    <div class="empty-state">
                        <div class="empty-icon">R</div>
                        <div data-i18n="emptyState">Select a dataset or upload a file</div>
                    </div>
                </div>
                <div class="pagination" id="pagination" style="display: none;">
                    <button id="prevBtn" data-i18n="prev">&lt; Prev</button>
                    <div class="page-info">
                        <span data-i18n="graph">Graph</span> <span id="currentPage">1</span> / <span id="totalPages">1</span>
                    </div>
                    <button id="nextBtn" data-i18n="next">Next &gt;</button>
                </div>
            </div>
        </div>

        <!-- Introduction Modal -->
        <div class="modal" id="introModal">
            <div class="modal-overlay"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h2 data-i18n="introTitle">What is a Ramsey Graph?</h2>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-body" id="introBody">
                </div>
            </div>
        </div>

        <!-- Progress Modal -->
        <div class="modal" id="progressModal">
            <div class="modal-overlay"></div>
            <div class="modal-content modal-large">
                <div class="modal-header">
                    <h2 data-i18n="progressTitle">Known Ramsey Numbers</h2>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-body" id="progressBody">
                </div>
            </div>
        </div>

        <!-- Challenge Mode -->
        <div class="challenge-mode" id="challengeMode">
            <div class="challenge-header">
                <div class="challenge-title">
                    <span data-i18n="challengeTitle">Challenge Mode</span>
                    <div class="challenge-params">
                        <label>s=</label>
                        <select id="challengeS"></select>
                        <label>t=</label>
                        <select id="challengeT"></select>
                        <label>n=</label>
                        <select id="challengeN"></select>
                        <button class="btn" id="startChallengeBtn" style="padding: 6px 12px; width: auto;" data-i18n="startChallenge">Start</button>
                    </div>
                </div>
                <div class="challenge-actions">
                    <select id="importGraphSelect" class="import-select">
                        <option value="" data-i18n="importFrom">Import from...</option>
                    </select>
                    <button class="btn" id="importGraphBtn" style="padding: 6px 12px; width: auto;" data-i18n="import">Import</button>
                    <button class="btn" id="resetChallengeBtn" style="padding: 6px 12px; width: auto;" data-i18n="reset">Reset</button>
                    <button class="btn" id="closeChallengeBtn" style="padding: 6px 12px; width: auto;" data-i18n="close">Close</button>
                </div>
            </div>
            <div class="challenge-main">
                <div class="challenge-left">
                    <div class="challenge-panel-header">
                        <span data-i18n="forceGraph">Force-Directed Graph</span>
                        <div class="legend" style="font-size: 9px;">
                            <div class="legend-item"><div class="legend-dot red"></div><span data-i18n="edge">Edge</span></div>
                            <div class="legend-item"><div class="legend-dot blue"></div><span data-i18n="noEdge">No Edge</span></div>
                        </div>
                    </div>
                    <div class="challenge-canvas" id="challengeCanvas"></div>
                </div>
                <div class="challenge-right">
                    <div class="challenge-panel-header">
                        <span data-i18n="adjacencyMatrix">Adjacency Matrix</span>
                        <span style="font-size: 9px; color: var(--text-secondary);" data-i18n="clickToFlip">Click to flip edges</span>
                    </div>
                    <div class="challenge-matrix-container" id="challengeMatrixContainer"></div>
                </div>
            </div>
            <div class="challenge-status">
                <div class="status-item">
                    <span class="status-indicator" id="cliqueIndicator"></span>
                    <span id="cliqueStatus" data-i18n="noClique">No K_s clique found</span>
                </div>
                <div class="status-item">
                    <span class="status-indicator" id="indepIndicator"></span>
                    <span id="indepStatus" data-i18n="noIndep">No K_t independent set found</span>
                </div>
                <div class="found-structures" id="foundStructures"></div>
                <div class="status-item">
                    <span id="edgeCountStatus"></span>
                </div>
            </div>
            <div class="success-overlay" id="successOverlay">
                <div class="success-content">
                    <div class="success-icon">üèÜ</div>
                    <div class="success-title" data-i18n="congratulations">Congratulations!</div>
                    <div class="success-message" id="successMessage" data-i18n="successMsg">
                        You found a valid Ramsey graph! This could improve the lower bound!
                    </div>
                    <button class="btn" id="closeSuccessBtn" style="margin-top: 20px; width: auto; padding: 10px 30px;" data-i18n="continue">Continue Exploring</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // i18n translations
        const i18n = {
            en: {
                subtitle: 'Interactive Visualizer',
                selectDataset: 'Select Dataset',
                loadDataset: 'Load Ramsey(s,t,n)',
                customSource: 'Custom Source',
                urlPlaceholder: 'Enter .g6 file URL...',
                loadUrl: 'Load URL',
                or: 'or',
                uploadFile: 'Drop or click to upload .g6 file',
                links: 'Links',
                hfDataset: 'HuggingFace Dataset',
                ghRepo: 'GitHub Repository',
                originDb: 'Origin Database',
                contact: 'Contact',
                wiki: 'E-JC Survey',
                nodes: 'Nodes',
                edges: 'Edges',
                graphG: 'Graph G',
                complement: 'Complement',
                force: 'Force',
                matrix: 'Matrix',
                both: 'Both',
                emptyState: 'Select a dataset or upload a file',
                prev: '< Prev',
                next: 'Next >',
                graph: 'Graph',
                loading: 'Loading',
                loadedGraphs: 'Loaded {0} graph(s)',
                noValidGraphs: 'No valid graphs found',
                errorLoading: 'Error: {0}',
                failedToLoad: 'Failed to load',
                graphCount: '{0} graph(s)',
                compressed: '(compressed)',
                introduction: 'Introduction',
                progress: 'Progress',
                introTitle: 'What is a Ramsey Graph?',
                progressTitle: 'Known Ramsey Numbers',
                exactValue: 'Exact value known',
                rangeValue: 'Only bounds known',
                wikiLink: 'Wikipedia',
                editInChallenge: 'Edit in Challenge',
                challenge: 'Challenge',
                challengeTitle: 'Challenge Mode',
                startChallenge: 'Start',
                importFrom: 'Import from...',
                import: 'Import',
                reset: 'Reset',
                close: 'Close',
                forceGraph: 'Force-Directed Graph',
                adjacencyMatrix: 'Adjacency Matrix',
                clickToFlip: 'Click to flip edges',
                edge: 'Edge',
                noEdge: 'No Edge',
                noClique: 'No K_{0} clique found',
                noIndep: 'No K_{0} independent set found',
                foundClique: 'Found K_{0} clique: {1}',
                foundIndep: 'Found K_{0} independent set: {1}',
                congratulations: 'Congratulations!',
                successMsg: 'You found a valid Ramsey({0},{1},{2}) graph! This could improve the lower bound of R({0},{1}) from {3} to {4}!',
                continue: 'Continue Exploring',
                edgeCountLabel: 'Edges: {0}',
                challengeHint: 'Try to construct a graph with no K_{0} clique and no K_{1} independent set',
                beyondProgress: 'Beyond current progress!',
                importGraphN: 'Import from n={0}'
            },
            zh: {
                subtitle: '‰∫§‰∫íÂºèÂèØËßÜÂåñÂ∑•ÂÖ∑',
                selectDataset: 'ÈÄâÊã©Êï∞ÊçÆÈõÜ',
                loadDataset: 'Âä†ËΩΩ Ramsey(s,t,n)',
                customSource: 'Ëá™ÂÆö‰πâÊù•Ê∫ê',
                urlPlaceholder: 'ËæìÂÖ• .g6 Êñá‰ª∂ URL...',
                loadUrl: 'Âä†ËΩΩ URL',
                or: 'Êàñ',
                uploadFile: 'ÊãñÊîæÊàñÁÇπÂáª‰∏ä‰º† .g6 Êñá‰ª∂',
                links: 'ÈìæÊé•',
                hfDataset: 'HuggingFace Êï∞ÊçÆÈõÜ',
                ghRepo: 'GitHub ‰ªìÂ∫ì',
                originDb: 'ÂéüÂßãÊï∞ÊçÆÂ∫ì',
                contact: 'ËÅîÁ≥ªÊñπÂºè',
                wiki: 'ÁîµÂ≠êÁªÑÂêàÂ≠¶ÊúüÂàä',
                nodes: 'ËäÇÁÇπ',
                edges: 'Ëæπ',
                graphG: 'Âõæ G',
                complement: 'Ë°•Âõæ',
                force: 'ÂäõÂØºÂêë',
                matrix: 'Áü©Èòµ',
                both: '‰∏§ËÄÖ',
                emptyState: 'ÈÄâÊã©Êï∞ÊçÆÈõÜÊàñ‰∏ä‰º†Êñá‰ª∂',
                prev: '< ‰∏ä‰∏Ä‰∏™',
                next: '‰∏ã‰∏Ä‰∏™ >',
                graph: 'Âõæ',
                loading: 'Âä†ËΩΩ‰∏≠',
                loadedGraphs: 'Â∑≤Âä†ËΩΩ {0} ‰∏™Âõæ',
                noValidGraphs: 'Êú™ÊâæÂà∞ÊúâÊïàÁöÑÂõæ',
                errorLoading: 'ÈîôËØØ: {0}',
                failedToLoad: 'Âä†ËΩΩÂ§±Ë¥•',
                graphCount: '{0} ‰∏™Âõæ',
                compressed: '(ÂéãÁº©)',
                introduction: '‰ªãÁªç',
                progress: 'ËøõÂ±ï',
                introTitle: '‰ªÄ‰πàÊòØÊãâÂßÜÈΩêÂõæÔºü',
                progressTitle: 'Â∑≤Áü•ÊãâÂßÜÈΩêÊï∞',
                exactValue: 'Á≤æÁ°ÆÂÄºÂ∑≤Áü•',
                rangeValue: '‰ªÖÁü•ÈÅì‰∏ä‰∏ãÁïå',
                wikiLink: 'Áª¥Âü∫ÁôæÁßë',
                editInChallenge: 'Âú®ÊåëÊàò‰∏≠ÁºñËæë',
                challenge: 'ÊåëÊàò',
                challengeTitle: 'ÊåëÊàòÊ®°Âºè',
                startChallenge: 'ÂºÄÂßã',
                importFrom: 'ÂØºÂÖ•Ëá™...',
                import: 'ÂØºÂÖ•',
                reset: 'ÈáçÁΩÆ',
                close: 'ÂÖ≥Èó≠',
                forceGraph: 'ÂäõÂØºÂêëÂõæ',
                adjacencyMatrix: 'ÈÇªÊé•Áü©Èòµ',
                clickToFlip: 'ÁÇπÂáªÁøªËΩ¨Ëæπ',
                edge: 'ÊúâËæπ',
                noEdge: 'Êó†Ëæπ',
                noClique: 'Êú™ÂèëÁé∞ K_{0} Âõ¢',
                noIndep: 'Êú™ÂèëÁé∞ K_{0} Áã¨Á´ãÈõÜ',
                foundClique: 'ÂèëÁé∞ K_{0} Âõ¢: {1}',
                foundIndep: 'ÂèëÁé∞ K_{0} Áã¨Á´ãÈõÜ: {1}',
                congratulations: 'ÊÅ≠ÂñúÔºÅ',
                successMsg: '‰Ω†ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÊúâÊïàÁöÑ Ramsey({0},{1},{2}) ÂõæÔºÅËøôÂèØ‰ª•Â∞Ü R({0},{1}) ÁöÑ‰∏ãÁïå‰ªé {3} ÊèêÂçáÂà∞ {4}ÔºÅ',
                continue: 'ÁªßÁª≠Êé¢Á¥¢',
                edgeCountLabel: 'ËæπÊï∞: {0}',
                challengeHint: 'Â∞ùËØïÊûÑÈÄ†‰∏Ä‰∏™Êó¢Ê≤°Êúâ K_{0} Âõ¢‰πüÊ≤°Êúâ K_{1} Áã¨Á´ãÈõÜÁöÑÂõæ',
                beyondProgress: 'Ë∂ÖË∂äÂΩìÂâçËøõÂ±ïÔºÅ',
                importGraphN: '‰ªé n={0} ÂØºÂÖ•'
            }
        };

        const wikiUrls = {
            en: 'https://en.wikipedia.org/wiki/Ramsey%27s_theorem',
            zh: 'https://zh.wikipedia.org/wiki/%E6%8B%89%E5%A7%86%E9%BD%90%E5%AE%9A%E7%90%86'
        };

        let currentLang = localStorage.getItem('lang') || 'en';

        function t(key, ...args) {
            let text = i18n[currentLang][key] || i18n['en'][key] || key;
            args.forEach((arg, i) => {
                text = text.replace(`{${i}}`, arg);
            });
            return text;
        }

        function applyLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                el.placeholder = t(key);
            });
            // Update wiki link URL based on language
            const wikiLink = document.getElementById('wikiLink');
            if (wikiLink) {
                wikiLink.href = wikiUrls[currentLang] || wikiUrls.en;
            }
            // Update dataset info if loaded
            if (selectS.value) updateDatasetInfo();
        }

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
            applyLanguage();
        }

        // Dataset configuration based on data/ folder
        const DATASETS = {
            '3,4': [1,2,3,4,5,6,7,8],
            '3,5': [1,2,3,4,5,6,7,8,9,10,11,12,13],
            '3,6': [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],
            '3,7': [21,22],
            '3,8': [27],
            '3,9': [35],
            '4,4': [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],
            '4,5': [24],
            '4,6': [35],
            '5,5': [42]
        };

        // Files that are compressed (gzipped)
        const COMPRESSED = new Set([
            'r36_11', 'r36_12', 'r36_13', 'r36_14', 'r36_15', 'r36_16',
            'r37_21', 'r38_27',
            'r44_10', 'r44_11', 'r44_12', 'r44_13', 'r44_14'
        ]);

        // Approximate graph counts for info display
        const GRAPH_COUNTS = {
            'r34_1':1,'r34_2':2,'r34_3':3,'r34_4':6,'r34_5':9,'r34_6':15,'r34_7':9,'r34_8':3,
            'r35_1':1,'r35_2':2,'r35_3':3,'r35_4':7,'r35_5':13,'r35_6':32,'r35_7':71,'r35_8':179,'r35_9':290,'r35_10':313,'r35_11':105,'r35_12':12,'r35_13':1,
            'r36_1':1,'r36_2':2,'r36_3':3,'r36_4':7,'r36_5':14,'r36_6':37,'r36_7':100,'r36_8':356,'r36_9':1407,'r36_10':6657,'r36_11':30395,'r36_12':116792,'r36_13':275086,'r36_14':263520,'r36_15':64732,'r36_16':2576,'r36_17':7,
            'r37_21':1118436,'r37_22':191,
            'r38_27':477142,
            'r39_35':1,
            'r44_1':1,'r44_2':2,'r44_3':4,'r44_4':9,'r44_5':24,'r44_6':84,'r44_7':362,'r44_8':2079,'r44_9':14701,'r44_10':103706,'r44_11':546356,'r44_12':1449166,'r44_13':1184231,'r44_14':130816,'r44_15':640,'r44_16':2,'r44_17':1,
            'r45_24':352366,
            'r46_35some':37,
            'r55_42some':328
        };

        // State
        let graphs = [];
        let currentIndex = 0;
        let viewMode = 'graph';
        let displayMode = 'force';
        let simulation = null;

        // DOM
        const selectS = document.getElementById('selectS');
        const selectT = document.getElementById('selectT');
        const selectN = document.getElementById('selectN');
        const loadDatasetBtn = document.getElementById('loadDatasetBtn');
        const datasetInfo = document.getElementById('datasetInfo');
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const fileInput = document.getElementById('fileInput');
        const fileLabel = document.getElementById('fileLabel');
        const status = document.getElementById('status');
        const canvas = document.getElementById('canvas');
        const pagination = document.getElementById('pagination');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const currentPage = document.getElementById('currentPage');
        const totalPages = document.getElementById('totalPages');
        const nodeCount = document.getElementById('nodeCount');
        const edgeCount = document.getElementById('edgeCount');

        // Initialize selectors
        function initSelectors() {
            const sValues = [...new Set(Object.keys(DATASETS).map(k => k.split(',')[0]))].sort((a,b) => a-b);
            selectS.innerHTML = sValues.map(s => `<option value="${s}">${s}</option>`).join('');
            updateTOptions();
        }

        function updateTOptions() {
            const s = selectS.value;
            const tValues = [...new Set(Object.keys(DATASETS).filter(k => k.startsWith(s+',')).map(k => k.split(',')[1]))].sort((a,b) => a-b);
            selectT.innerHTML = tValues.map(t => `<option value="${t}">${t}</option>`).join('');
            updateNOptions();
        }

        function updateNOptions() {
            const key = `${selectS.value},${selectT.value}`;
            const nValues = DATASETS[key] || [];
            selectN.innerHTML = nValues.map(n => `<option value="${n}">${n}</option>`).join('');
            updateDatasetInfo();
        }

        function updateDatasetInfo() {
            const s = selectS.value, tVal = selectT.value, n = selectN.value;
            const fileKey = `r${s}${tVal}_${n}`;
            const count = GRAPH_COUNTS[fileKey] || GRAPH_COUNTS[fileKey + 'some'] || '?';
            const isCompressed = COMPRESSED.has(fileKey);
            const countText = t('graphCount', count.toLocaleString());
            datasetInfo.innerHTML = `${countText}${isCompressed ? ` <span style="color:var(--accent-blue)">${t('compressed')}</span>` : ''}`;
        }

        function getDatasetUrl() {
            const sVal = selectS.value, tVal = selectT.value, nVal = selectN.value;
            let fileKey = `r${sVal}${tVal}_${nVal}`;
            if (['4,6', '5,5'].includes(`${sVal},${tVal}`)) {
                fileKey += 'some';
            }
            const ext = COMPRESSED.has(fileKey.replace('some','')) ? '.g6.gz' : '.g6';
            return `https://huggingface.co/datasets/linxy/RamseyGraph/resolve/main/data/${fileKey}${ext}?download=true`;
        }

        selectS.addEventListener('change', updateTOptions);
        selectT.addEventListener('change', updateNOptions);
        selectN.addEventListener('change', updateDatasetInfo);

        // Status helper
        function showStatus(msg, type = 'info') {
            status.textContent = msg;
            status.className = `status show ${type}`;
            if (type !== 'error') {
                setTimeout(() => status.className = 'status', 3000);
            }
        }

        // Parse graph6
        function parseGraph6(line) {
            line = line.trim();
            if (!line) return null;

            let pos = 0;
            let n;
            const firstByte = line.charCodeAt(pos) - 63;

            if (firstByte < 63) {
                n = firstByte;
                pos++;
            } else if (line.charCodeAt(pos + 1) - 63 < 63) {
                n = ((line.charCodeAt(pos + 1) - 63) << 12) |
                    ((line.charCodeAt(pos + 2) - 63) << 6) |
                    (line.charCodeAt(pos + 3) - 63);
                pos += 4;
            } else {
                n = ((line.charCodeAt(pos + 2) - 63) << 30) |
                    ((line.charCodeAt(pos + 3) - 63) << 24) |
                    ((line.charCodeAt(pos + 4) - 63) << 18) |
                    ((line.charCodeAt(pos + 5) - 63) << 12) |
                    ((line.charCodeAt(pos + 6) - 63) << 6) |
                    (line.charCodeAt(pos + 7) - 63);
                pos += 8;
            }

            const edges = [];
            let bitPos = 0;
            let currentByte = 0;

            for (let j = 1; j < n; j++) {
                for (let i = 0; i < j; i++) {
                    if (bitPos === 0) {
                        if (pos >= line.length) break;
                        currentByte = line.charCodeAt(pos) - 63;
                        pos++;
                    }
                    const bit = (currentByte >> (5 - bitPos)) & 1;
                    bitPos = (bitPos + 1) % 6;
                    if (bit === 1) edges.push([i, j]);
                }
            }

            return { nodes: n, edges };
        }

        // Load functions
        async function loadFromUrl(url) {
            showStatus(t('loading') + '...', 'info');
            canvas.innerHTML = `<div class="loading">${t('loading')}</div>`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                let text;
                if (url.includes('.gz')) {
                    const buffer = await response.arrayBuffer();
                    const decompressed = await decompress(buffer);
                    text = new TextDecoder().decode(decompressed);
                } else {
                    text = await response.text();
                }

                parseAndDisplay(text);
                showStatus(t('loadedGraphs', graphs.length), 'success');
            } catch (err) {
                showStatus(t('errorLoading', err.message), 'error');
                canvas.innerHTML = `<div class="empty-state"><div class="empty-icon">!</div><div>${t('failedToLoad')}</div></div>`;
            }
        }

        async function decompress(buffer) {
            const ds = new DecompressionStream('gzip');
            const decompressedStream = new Response(new Blob([buffer]).stream().pipeThrough(ds)).arrayBuffer();
            return new Uint8Array(await decompressedStream);
        }

        function loadFromFile(file) {
            showStatus(t('loading') + '...', 'info');
            const reader = new FileReader();

            reader.onload = async (e) => {
                let text;
                if (file.name.endsWith('.gz')) {
                    const decompressed = await decompress(e.target.result);
                    text = new TextDecoder().decode(decompressed);
                } else {
                    text = e.target.result;
                }
                parseAndDisplay(text);
                showStatus(t('loadedGraphs', graphs.length), 'success');
            };

            reader.onerror = () => showStatus(t('errorLoading', 'File read error'), 'error');

            if (file.name.endsWith('.gz')) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        function parseAndDisplay(text) {
            graphs = [];
            const lines = text.split('\n');
            for (const line of lines) {
                const g = parseGraph6(line);
                if (g) graphs.push(g);
            }

            if (graphs.length > 0) {
                currentIndex = 0;
                updatePagination();
                visualize(0);
            } else {
                showStatus(t('noValidGraphs'), 'error');
            }
        }

        function updatePagination() {
            pagination.style.display = graphs.length > 1 ? 'flex' : 'none';
            currentPage.textContent = currentIndex + 1;
            totalPages.textContent = graphs.length;
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === graphs.length - 1;
        }

        function getComplement(n, edges) {
            const set = new Set(edges.map(e => `${e[0]}-${e[1]}`));
            const comp = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (!set.has(`${i}-${j}`)) comp.push([i, j]);
                }
            }
            return comp;
        }

        // Build adjacency matrix
        function buildAdjMatrix(n, edges) {
            const matrix = Array.from({ length: n }, () => Array(n).fill(0));
            for (const [i, j] of edges) {
                matrix[i][j] = 1;
                matrix[j][i] = 1;
            }
            return matrix;
        }

        // Main visualization dispatcher
        function visualize(index) {
            if (index < 0 || index >= graphs.length) return;
            currentIndex = index;
            const g = graphs[index];

            nodeCount.textContent = g.nodes;
            edgeCount.textContent = g.edges.length;
            updatePagination();

            if (displayMode === 'force') {
                visualizeForce(g);
            } else {
                visualizeMatrix(g);
            }
        }

        // Force-directed graph visualization
        function visualizeForce(g) {
            canvas.innerHTML = '';

            const nodes = Array.from({ length: g.nodes }, (_, i) => ({ id: i }));
            let links = [];

            if (viewMode === 'graph') {
                links = g.edges.map(e => ({ source: e[0], target: e[1], type: 'graph' }));
            } else if (viewMode === 'complement') {
                links = getComplement(g.nodes, g.edges).map(e => ({ source: e[0], target: e[1], type: 'complement' }));
            } else {
                links = g.edges.map(e => ({ source: e[0], target: e[1], type: 'graph' }));
                links = links.concat(getComplement(g.nodes, g.edges).map(e => ({ source: e[0], target: e[1], type: 'complement' })));
            }

            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            const svg = d3.select('#canvas').append('svg').attr('width', width).attr('height', height);

            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(60))
                .force('charge', d3.forceManyBody().strength(-150))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(16));

            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke', d => d.type === 'graph' ? '#ff3366' : '#00d4ff')
                .attr('stroke-width', 2);

            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', 8)
                .attr('fill', '#e8e8e8')
                .call(drag(simulation));

            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .attr('class', 'node-label')
                .text(d => d.id);

            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('cx', d => d.x).attr('cy', d => d.y);
                label.attr('x', d => d.x).attr('y', d => d.y + 20);
            });
        }

        // Matrix visualization
        function visualizeMatrix(g) {
            canvas.innerHTML = '';

            const n = g.nodes;
            const edgeMatrix = buildAdjMatrix(n, g.edges);
            const compMatrix = buildAdjMatrix(n, getComplement(n, g.edges));

            // Calculate cell size based on available space
            const rect = canvas.getBoundingClientRect();
            const availableSize = Math.min(rect.width - 80, rect.height - 60);
            const cellSize = Math.max(16, Math.min(32, Math.floor(availableSize / n)));

            const container = document.createElement('div');
            container.className = 'matrix-container';

            const wrapper = document.createElement('div');
            wrapper.className = 'matrix-wrapper';
            wrapper.style.setProperty('--cell-size', `${cellSize}px`);

            // Top labels
            const topLabels = document.createElement('div');
            topLabels.className = 'matrix-labels-top';
            for (let j = 0; j < n; j++) {
                const label = document.createElement('div');
                label.className = 'matrix-label';
                label.textContent = j;
                topLabels.appendChild(label);
            }
            wrapper.appendChild(topLabels);

            // Matrix rows
            for (let i = 0; i < n; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';

                // Row label
                const rowLabel = document.createElement('div');
                rowLabel.className = 'matrix-row-label';
                rowLabel.textContent = i;
                row.appendChild(rowLabel);

                // Cells
                for (let j = 0; j < n; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';

                    if (i === j) {
                        cell.classList.add('diagonal');
                        cell.textContent = '-';
                    } else {
                        const isEdge = edgeMatrix[i][j] === 1;
                        const isComp = compMatrix[i][j] === 1;

                        if (viewMode === 'graph') {
                            if (isEdge) {
                                cell.classList.add('edge');
                                cell.textContent = '1';
                            } else {
                                cell.classList.add('empty');
                                cell.textContent = '0';
                            }
                        } else if (viewMode === 'complement') {
                            if (isComp) {
                                cell.classList.add('complement');
                                cell.textContent = '1';
                            } else {
                                cell.classList.add('empty');
                                cell.textContent = '0';
                            }
                        } else { // both
                            if (isEdge) {
                                cell.classList.add('edge');
                                cell.textContent = '1';
                            } else if (isComp) {
                                cell.classList.add('complement');
                                cell.textContent = '1';
                            } else {
                                cell.classList.add('empty');
                                cell.textContent = '0';
                            }
                        }
                    }

                    cell.title = `(${i}, ${j})`;
                    row.appendChild(cell);
                }

                wrapper.appendChild(row);
            }

            container.appendChild(wrapper);
            canvas.appendChild(container);
        }

        function drag(sim) {
            return d3.drag()
                .on('start', e => { if (!e.active) sim.alphaTarget(0.3).restart(); e.subject.fx = e.subject.x; e.subject.fy = e.subject.y; })
                .on('drag', e => { e.subject.fx = e.x; e.subject.fy = e.y; })
                .on('end', e => { if (!e.active) sim.alphaTarget(0); e.subject.fx = null; e.subject.fy = null; });
        }

        // Event listeners
        loadDatasetBtn.addEventListener('click', () => loadFromUrl(getDatasetUrl()));

        loadUrlBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) loadFromUrl(url);
        });

        urlInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') loadUrlBtn.click();
        });

        fileInput.addEventListener('change', e => {
            if (e.target.files[0]) {
                fileLabel.textContent = e.target.files[0].name;
                fileLabel.classList.add('has-file');
                loadFromFile(e.target.files[0]);
            }
        });

        prevBtn.addEventListener('click', () => { if (currentIndex > 0) visualize(currentIndex - 1); });
        nextBtn.addEventListener('click', () => { if (currentIndex < graphs.length - 1) visualize(currentIndex + 1); });

        // Display mode toggle (Force / Matrix)
        document.querySelectorAll('#displayToggle .toggle-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('#displayToggle .toggle-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                displayMode = e.target.dataset.display;
                if (graphs.length > 0) visualize(currentIndex);
            });
        });

        // View mode toggle (G / G' / Both)
        document.querySelectorAll('#viewToggle .toggle-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('#viewToggle .toggle-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                viewMode = e.target.dataset.mode;
                if (graphs.length > 0) visualize(currentIndex);
            });
        });

        // Keyboard navigation
        document.addEventListener('keydown', e => {
            if (graphs.length === 0) return;
            if (e.key === 'ArrowLeft' || e.key === 'a') prevBtn.click();
            if (e.key === 'ArrowRight' || e.key === 'd') nextBtn.click();
            if (e.key === 'm') {
                displayMode = displayMode === 'force' ? 'matrix' : 'force';
                document.querySelectorAll('#displayToggle .toggle-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.display === displayMode);
                });
                visualize(currentIndex);
            }
        });

        // Language toggle
        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
        });

        // Modal content
        const trophyIcon = '<svg style="width:16px;height:16px;vertical-align:middle;margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></svg>';
        const lightbulbIcon = '<svg style="width:16px;height:16px;vertical-align:middle;margin-right:4px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"></path><path d="M9 18h6"></path><path d="M10 22h4"></path></svg>';
        const introContent = {
            en: `
                <p><strong>A Ramsey(s,t,n) graph</strong> is a graph with <span class="highlight">n vertices</span> that contains no clique of size s and no independent set of size t.</p>
                <p>The <strong>Ramsey Theorem</strong> states that for given s and t, the number of Ramsey(s,t) graphs is finite. The minimum number of vertices for which no such graph exists is called the <strong>Ramsey Number R(s,t)</strong>.</p>
                <p>For given s and t, as the number of vertices n increases, there exists a <span class="highlight">critical threshold</span>‚Äîonce n exceeds this threshold, a clique of size s or an independent set of size t <strong>must</strong> exist in any graph. Finding Ramsey graphs means finding this critical vertex count: the exact point where we can still find at least one special graph that contains neither a clique of size s nor an independent set of size t.</p>
                <div class="significance">
                    <strong>${lightbulbIcon}Why It Matters:</strong> If we had an algorithm to determine the exact Ramsey number in advance, we would know precisely when certain substructures <strong>must</strong> appear in a system. This knowledge could help avoid maintaining excess nodes, potentially saving significant costs in network design, distributed systems, and other applications.
                </div>
                <p>Finding all such graphs, or even determining the maximum n for which they exist, is a famous problem in combinatorics. Most Ramsey numbers are still unknown‚Äîwe only know upper and lower bounds.</p>
                <div class="challenge">
                    <strong>${trophyIcon}Open Challenge:</strong> Find a <span class="highlight">Ramsey(5,5) graph with 43 vertices</span>!<br><br>
                    All 42-vertex Ramsey(5,5) graphs have been found, but it's unknown if a 43-vertex one exists. The lower bound of R(5,5) hasn't been improved since <strong>1989</strong>. Finding just one such graph would be a major breakthrough‚Äî${new Date().getFullYear() - 1989} years in the making!
                </div>
                <p>For the latest research on Ramsey graphs, see <strong>Radziszowski's</strong> dynamic survey published in the <a href="https://www.combinatorics.org" target="_blank" style="color: var(--accent-blue);">Electronic Journal of Combinatorics</a>.</p>
            `,
            zh: `
                <p><strong>Ramsey(s,t,n) Âõæ</strong>ÊòØÂÖ∑Êúâ <span class="highlight">n ‰∏™È°∂ÁÇπ</span>ÁöÑÂõæÔºåÂÆÉ‰∏çÂåÖÂê´Â§ßÂ∞è‰∏∫ s ÁöÑÂõ¢Ôºå‰πü‰∏çÂåÖÂê´Â§ßÂ∞è‰∏∫ t ÁöÑÁã¨Á´ãÈõÜ„ÄÇ</p>
                <p><strong>ÊãâÂßÜÈΩêÂÆöÁêÜ</strong>Ë°®ÊòéÔºåÂØπ‰∫éÁªôÂÆöÁöÑ s Âíå tÔºåRamsey(s,t) ÂõæÁöÑÊï∞ÈáèÊòØÊúâÈôêÁöÑ„ÄÇÊª°Ë∂≥ËøôÁßçÂõæÂ≠òÂú®ÁöÑÊúÄÂ∞èÈ°∂ÁÇπÊï∞Áß∞‰∏∫<strong>ÊãâÂßÜÈΩêÊï∞ R(s,t)</strong>„ÄÇ</p>
                <p>ÂØπ‰∫éÁªôÂÆöÁöÑ s Âíå tÔºåÂΩìËäÇÁÇπÊï∞Èáè n Â¢ûÂä†Êó∂ÔºåÂ≠òÂú®‰∏Ä‰∏™<span class="highlight">‰∏¥ÁïåÊï∞Èáè</span>‚Äî‚Äî‰∏ÄÊó¶ËäÇÁÇπÊï∞Ë∂ÖËøáËøô‰∏™‰∏¥ÁïåÂÄºÔºåÂ§ßÂ∞è‰∏∫ s ÁöÑÂõ¢ÊàñÂ§ßÂ∞è‰∏∫ t ÁöÑÁã¨Á´ãÈõÜÂ∞±<strong>‰∏ÄÂÆö</strong>Â≠òÂú®‰∫é‰ªªÊÑèÂõæ‰∏≠„ÄÇÂØªÊâæ Ramsey ÂõæÂ∞±ÊòØÂú®ÂØªÊâæËøô‰∏™‰∏¥ÁïåËäÇÁÇπÊï∞ÔºöÂú®Ëøô‰∏™ËäÇÁÇπÊï∞Èáè‰∏ãÔºåÊàë‰ª¨ÊÅ∞Â•ΩËá≥Â∞ëËÉΩÊâæÂà∞‰∏Ä‰∏™ÂæàÁâπÊÆäÁöÑÂõæÔºåÂÆÉÊó¢‰∏çÂåÖÂê´Â§ßÂ∞è‰∏∫ s ÁöÑÂõ¢Ôºå‰πü‰∏çÂåÖÂê´Â§ßÂ∞è‰∏∫ t ÁöÑÁã¨Á´ãÈõÜ„ÄÇ</p>
                <div class="significance">
                    <strong>${lightbulbIcon}ÈáçË¶ÅÊÑè‰πâÔºö</strong>Â¶ÇÊûúÊàë‰ª¨ËÉΩÊúâ‰∏ÄÁßçÁÆóÊ≥ïÊèêÂâçÁü•ÈÅìÊãâÂßÜÈΩêÊï∞ÁöÑÂÖ∑‰ΩìÂÄºÔºåÂ∞±Áõ∏ÂΩì‰∫éÁü•ÈÅìÁ≥ªÁªü‰∏≠ÊüêÁßçÂ≠êÁªìÊûÑÂú®‰ªÄ‰πàÊó∂ÂÄô<strong>ÂøÖÁÑ∂</strong>ÂºÄÂßãÂ≠òÂú®„ÄÇËøôÊ†∑Â∞±‰∏çÁî®‰øùÊåÅËøáÈáèÁöÑËäÇÁÇπÔºå‰ªéËÄåÂú®ÁΩëÁªúËÆæËÆ°„ÄÅÂàÜÂ∏ÉÂºèÁ≥ªÁªüÁ≠âÂ∫îÁî®‰∏≠ËäÇÁúÅÊàêÊú¨„ÄÇ
                </div>
                <p>ÊâæÂà∞ÊâÄÊúâËøôÊ†∑ÁöÑÂõæÔºåÁîöËá≥Á°ÆÂÆöÂÆÉ‰ª¨Â≠òÂú®ÁöÑÊúÄÂ§ß nÔºåÈÉΩÊòØÁªÑÂêàÊï∞Â≠¶‰∏≠ÁöÑËëóÂêçÈöæÈ¢ò„ÄÇÂ§ßÂ§öÊï∞ÊãâÂßÜÈΩêÊï∞‰ªçÁÑ∂Êú™Áü•‚Äî‚ÄîÊàë‰ª¨Âè™Áü•ÈÅìÂÆÉ‰ª¨ÁöÑ‰∏äÁïåÂíå‰∏ãÁïå„ÄÇ</p>
                <div class="challenge">
                    <strong>${trophyIcon}ÂºÄÊîæÊåëÊàòÔºö</strong>ÊâæÂà∞‰∏Ä‰∏™ <span class="highlight">43 È°∂ÁÇπÁöÑ Ramsey(5,5) Âõæ</span>ÔºÅ<br><br>
                    ÁõÆÂâçÊâÄÊúâ 42 È°∂ÁÇπÁöÑ Ramsey(5,5) ÂõæÈÉΩÂ∑≤Ë¢´ÊâæÂà∞Ôºå‰ΩÜ‰∏çÁ°ÆÂÆöÊòØÂê¶Â≠òÂú® 43 È°∂ÁÇπÁöÑÂõæ„ÄÇR(5,5) ÁöÑ‰∏ãÁïåËá™ <strong>1989 Âπ¥</strong>‰ª•Êù•Â∞±Ê≤°ÊúâË¢´ÊîπËøõËøá„ÄÇÂè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂõæÔºåÂ∞±ÊòØËøô‰∏™È¢ÜÂüü ${new Date().getFullYear() - 1989} Âπ¥Êù•ÁöÑÈáçÂ§ßÁ™ÅÁ†¥ÔºÅ
                </div>
                <p>ÊúâÂÖ≥ Ramsey ÂõæÁöÑÊúÄÊñ∞Á†îÁ©∂ÔºåËØ∑ÂèÇËßÅ <strong>Radziszowski</strong> ÁöÑÂä®ÊÄÅÁªºËø∞ÔºåÊåÅÁª≠Êõ¥Êñ∞ÂàäÁôª‰∫é<a href="https://www.combinatorics.org" target="_blank" style="color: var(--accent-blue);">ÁîµÂ≠êÁªÑÂêàÂ≠¶ÊúüÂàä</a>„ÄÇ</p>
            `
        };

        const ramseyTable = [
            ['s\\t', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
            ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'],
            ['2', '-', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
            ['3', '-', '-', '6', '9', '14', '18', '23', '28', '36', '40-41'],
            ['4', '-', '-', '-', '18', '25', '36-40', '49-58', '59-79', '73-106', '92-136'],
            ['5', '-', '-', '-', '-', '43-48', '59-85', '80-133', '101-194', '133-282', '149-381'],
            ['6', '-', '-', '-', '-', '-', '102-161', '115-273', '134-427', '183-656', '204-949'],
            ['7', '-', '-', '-', '-', '-', '-', '205-497', '219-840', '252-1379', '292-2134'],
            ['8', '-', '-', '-', '-', '-', '-', '-', '282-1532', '329-2683', '343-4432'],
            ['9', '-', '-', '-', '-', '-', '-', '-', '-', '565-5366', '581-9797'],
            ['10', '-', '-', '-', '-', '-', '-', '-', '-', '-', '798-17730']
        ];

        function generateProgressTable() {
            let html = '<table class="ramsey-table"><thead><tr>';
            ramseyTable[0].forEach(h => html += `<th>${h}</th>`);
            html += '</tr></thead><tbody>';

            for (let i = 1; i < ramseyTable.length; i++) {
                html += '<tr>';
                ramseyTable[i].forEach((cell, j) => {
                    if (j === 0) {
                        html += `<th>${cell}</th>`;
                    } else if (cell === '-') {
                        html += `<td class="trivial">-</td>`;
                    } else if (cell.includes('-')) {
                        html += `<td class="range">${cell}</td>`;
                    } else {
                        html += `<td class="exact">${cell}</td>`;
                    }
                });
                html += '</tr>';
            }

            html += '</tbody></table>';
            html += `<div class="table-legend">
                <div class="table-legend-item"><div class="legend-box exact"></div><span data-i18n="exactValue">${t('exactValue')}</span></div>
                <div class="table-legend-item"><div class="legend-box range"></div><span data-i18n="rangeValue">${t('rangeValue')}</span></div>
            </div>`;
            return html;
        }

        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modalId === 'introModal') {
                document.getElementById('introBody').innerHTML = introContent[currentLang];
            } else if (modalId === 'progressModal') {
                document.getElementById('progressBody').innerHTML = generateProgressTable();
            }
            modal.classList.add('show');
        }

        function closeModal(modal) {
            modal.classList.remove('show');
        }

        // Modal event listeners
        document.getElementById('introBtn').addEventListener('click', () => openModal('introModal'));
        document.getElementById('progressBtn').addEventListener('click', () => openModal('progressModal'));

        document.querySelectorAll('.modal-overlay, .modal-close').forEach(el => {
            el.addEventListener('click', (e) => {
                const modal = e.target.closest('.modal');
                if (modal) closeModal(modal);
            });
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                document.querySelectorAll('.modal.show').forEach(m => closeModal(m));
            }
        });

        // =====================
        // Challenge Mode Logic
        // =====================

        // Known Ramsey number lower bounds (for determining "breakthrough")
        const RAMSEY_BOUNDS = {
            '3,3': { lower: 6, upper: 6 },
            '3,4': { lower: 9, upper: 9 },
            '3,5': { lower: 14, upper: 14 },
            '3,6': { lower: 18, upper: 18 },
            '3,7': { lower: 23, upper: 23 },
            '3,8': { lower: 28, upper: 28 },
            '3,9': { lower: 36, upper: 36 },
            '3,10': { lower: 40, upper: 41 },
            '4,4': { lower: 18, upper: 18 },
            '4,5': { lower: 25, upper: 25 },
            '4,6': { lower: 36, upper: 40 },
            '4,7': { lower: 49, upper: 58 },
            '4,8': { lower: 59, upper: 79 },
            '4,9': { lower: 73, upper: 106 },
            '4,10': { lower: 92, upper: 136 },
            '5,5': { lower: 43, upper: 48 },
            '5,6': { lower: 59, upper: 85 },
            '5,7': { lower: 80, upper: 133 },
            '5,8': { lower: 101, upper: 194 },
            '5,9': { lower: 133, upper: 282 },
            '5,10': { lower: 149, upper: 381 },
            '6,6': { lower: 102, upper: 161 },
            '6,7': { lower: 115, upper: 273 },
            '6,8': { lower: 134, upper: 427 },
            '6,9': { lower: 183, upper: 656 },
            '6,10': { lower: 204, upper: 949 }
        };

        // Challenge state
        let challengeState = {
            s: 5,
            t: 5,
            n: 43,
            adjMatrix: null,
            simulation: null,
            foundCliques: [],
            foundIndeps: []
        };

        // Challenge DOM elements
        const challengeMode = document.getElementById('challengeMode');
        const challengeS = document.getElementById('challengeS');
        const challengeT = document.getElementById('challengeT');
        const challengeN = document.getElementById('challengeN');
        const challengeCanvas = document.getElementById('challengeCanvas');
        const challengeMatrixContainer = document.getElementById('challengeMatrixContainer');
        const importGraphSelect = document.getElementById('importGraphSelect');
        const successOverlay = document.getElementById('successOverlay');

        // Initialize challenge selectors
        function initChallengeSelectors() {
            // s values 3-6
            for (let s = 3; s <= 6; s++) {
                challengeS.innerHTML += `<option value="${s}">${s}</option>`;
            }
            challengeS.value = 5;
            updateChallengeTOptions();
        }

        function updateChallengeTOptions() {
            const sVal = parseInt(challengeS.value);
            challengeT.innerHTML = '';
            for (let tOpt = sVal; tOpt <= 10; tOpt++) {
                challengeT.innerHTML += `<option value="${tOpt}">${tOpt}</option>`;
            }
            challengeT.value = Math.max(sVal, 5);
            updateChallengeNOptions();
        }

        function updateChallengeNOptions() {
            const sVal = parseInt(challengeS.value);
            const tVal = parseInt(challengeT.value);
            const key = `${Math.min(sVal,tVal)},${Math.max(sVal,tVal)}`;
            const bounds = RAMSEY_BOUNDS[key] || { lower: 10, upper: 100 };

            challengeN.innerHTML = '';
            // Allow n from lower bound - 5 to lower bound + 5
            const minN = Math.max(3, bounds.lower - 5);
            const maxN = bounds.lower + 5;
            for (let nOpt = minN; nOpt <= maxN; nOpt++) {
                const option = document.createElement('option');
                option.value = nOpt;
                option.textContent = nOpt;
                if (nOpt >= bounds.lower) {
                    option.textContent += ' ‚òÖ';
                }
                challengeN.appendChild(option);
            }
            challengeN.value = bounds.lower;
            updateImportOptions();
        }

        function updateImportOptions() {
            const sVal = parseInt(challengeS.value);
            const tVal = parseInt(challengeT.value);
            const nVal = parseInt(challengeN.value);

            importGraphSelect.innerHTML = `<option value="">${t('importFrom')}</option>`;

            // Find available datasets for smaller n
            const key = `${sVal},${tVal}`;
            const available = DATASETS[key] || [];
            available.filter(availN => availN < nVal).forEach(availN => {
                const option = document.createElement('option');
                option.value = availN;
                option.textContent = t('importGraphN', availN);
                importGraphSelect.appendChild(option);
            });
        }

        challengeS.addEventListener('change', updateChallengeTOptions);
        challengeT.addEventListener('change', updateChallengeNOptions);
        challengeN.addEventListener('change', updateImportOptions);

        // Open challenge mode
        function openChallengeMode(s = 5, t = 5, n = 43) {
            challengeS.value = s;
            updateChallengeTOptions();
            challengeT.value = t;
            updateChallengeNOptions();
            challengeN.value = n;
            updateImportOptions();

            challengeMode.classList.add('show');
            startChallenge();
        }

        // Close challenge mode
        function closeChallengeMode() {
            challengeMode.classList.remove('show');
            if (challengeState.simulation) {
                challengeState.simulation.stop();
            }
        }

        // Start a new challenge
        function startChallenge() {
            const sVal = parseInt(challengeS.value);
            const tVal = parseInt(challengeT.value);
            const nVal = parseInt(challengeN.value);

            challengeState.s = sVal;
            challengeState.t = tVal;
            challengeState.n = nVal;

            // Initialize empty adjacency matrix
            challengeState.adjMatrix = Array.from({ length: nVal }, () => Array(nVal).fill(0));

            // Random initialization: ~50% density
            for (let i = 0; i < nVal; i++) {
                for (let j = i + 1; j < nVal; j++) {
                    const hasEdge = Math.random() < 0.5 ? 1 : 0;
                    challengeState.adjMatrix[i][j] = hasEdge;
                    challengeState.adjMatrix[j][i] = hasEdge;
                }
            }

            renderChallengeViews();
            checkStructures();
        }

        // Reset to empty graph
        function resetChallenge() {
            const n = challengeState.n;
            challengeState.adjMatrix = Array.from({ length: n }, () => Array(n).fill(0));
            renderChallengeViews();
            checkStructures();
            successOverlay.classList.remove('show');
        }

        // Import from existing graph
        async function importFromDataset() {
            const importN = parseInt(importGraphSelect.value);
            if (!importN) return;

            const sVal = challengeState.s;
            const tVal = challengeState.t;
            const nVal = challengeState.n;

            // Build URL for the dataset
            let fileKey = `r${sVal}${tVal}_${importN}`;
            if (['4,6', '5,5'].includes(`${sVal},${tVal}`)) {
                fileKey += 'some';
            }
            const ext = COMPRESSED.has(fileKey.replace('some','')) ? '.g6.gz' : '.g6';
            const url = `https://huggingface.co/datasets/linxy/RamseyGraph/resolve/main/data/${fileKey}${ext}?download=true`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                let text;
                if (url.includes('.gz')) {
                    const buffer = await response.arrayBuffer();
                    const decompressed = await decompress(buffer);
                    text = new TextDecoder().decode(decompressed);
                } else {
                    text = await response.text();
                }

                const lines = text.split('\n');
                const firstGraph = parseGraph6(lines[0]);

                if (firstGraph) {
                    // Reset matrix
                    challengeState.adjMatrix = Array.from({ length: nVal }, () => Array(nVal).fill(0));

                    // Copy edges from imported graph
                    for (const [i, j] of firstGraph.edges) {
                        if (i < nVal && j < nVal) {
                            challengeState.adjMatrix[i][j] = 1;
                            challengeState.adjMatrix[j][i] = 1;
                        }
                    }

                    renderChallengeViews();
                    checkStructures();
                }
            } catch (err) {
                console.error('Import failed:', err);
            }
        }

        // Flip edge at (i, j)
        function flipEdge(i, j) {
            if (i === j) return;

            const current = challengeState.adjMatrix[i][j];
            challengeState.adjMatrix[i][j] = 1 - current;
            challengeState.adjMatrix[j][i] = 1 - current;

            renderChallengeViews();
            checkStructures();
        }

        // Render both views
        function renderChallengeViews() {
            renderChallengeMatrix();
            renderChallengeGraph();
        }

        // Render the interactive matrix
        function renderChallengeMatrix() {
            const n = challengeState.n;
            const matrix = challengeState.adjMatrix;

            // Calculate cell size
            const containerRect = challengeMatrixContainer.getBoundingClientRect();
            const availableSize = Math.min(containerRect.width - 60, containerRect.height - 40);
            const cellSize = Math.max(14, Math.min(24, Math.floor(availableSize / (n + 1))));

            challengeMatrixContainer.innerHTML = '';

            const wrapper = document.createElement('div');
            wrapper.className = 'matrix-wrapper';
            wrapper.style.setProperty('--cell-size', `${cellSize}px`);

            // Top labels
            const topLabels = document.createElement('div');
            topLabels.className = 'matrix-labels-top';
            for (let j = 0; j < n; j++) {
                const label = document.createElement('div');
                label.className = 'matrix-label';
                label.textContent = j;
                label.style.width = `${cellSize}px`;
                topLabels.appendChild(label);
            }
            wrapper.appendChild(topLabels);

            // Matrix rows
            for (let i = 0; i < n; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';

                // Row label
                const rowLabel = document.createElement('div');
                rowLabel.className = 'matrix-row-label';
                rowLabel.textContent = i;
                rowLabel.style.height = `${cellSize}px`;
                row.appendChild(rowLabel);

                // Cells
                for (let j = 0; j < n; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'challenge-matrix-cell';
                    cell.dataset.i = i;
                    cell.dataset.j = j;

                    if (i === j) {
                        cell.classList.add('diagonal');
                        cell.textContent = '-';
                    } else {
                        const hasEdge = matrix[i][j] === 1;
                        cell.classList.add(hasEdge ? 'edge' : 'no-edge');
                        cell.textContent = hasEdge ? '1' : '0';

                        cell.addEventListener('click', () => flipEdge(i, j));
                    }

                    row.appendChild(cell);
                }

                wrapper.appendChild(row);
            }

            challengeMatrixContainer.appendChild(wrapper);
        }

        // Render the force-directed graph
        function renderChallengeGraph() {
            const n = challengeState.n;
            const matrix = challengeState.adjMatrix;

            challengeCanvas.innerHTML = '';

            const rect = challengeCanvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            if (width === 0 || height === 0) return;

            const svg = d3.select('#challengeCanvas').append('svg')
                .attr('width', width)
                .attr('height', height);

            // Add gradient definition for nodes in both clique and indep set
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'gradient-both')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '100%');
            gradient.append('stop')
                .attr('offset', '50%')
                .attr('stop-color', '#ff3366'); // red
            gradient.append('stop')
                .attr('offset', '50%')
                .attr('stop-color', '#00d4ff'); // blue

            // Add filter for double border effect (white inner + black outer)
            const filter = defs.append('filter')
                .attr('id', 'double-border')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');
            filter.append('feMorphology')
                .attr('in', 'SourceAlpha')
                .attr('operator', 'dilate')
                .attr('radius', '3')
                .attr('result', 'expanded');
            filter.append('feFlood')
                .attr('flood-color', '#000000')
                .attr('result', 'black');
            filter.append('feComposite')
                .attr('in', 'black')
                .attr('in2', 'expanded')
                .attr('operator', 'in')
                .attr('result', 'blackBorder');
            filter.append('feMorphology')
                .attr('in', 'SourceAlpha')
                .attr('operator', 'dilate')
                .attr('radius', '1.5')
                .attr('result', 'expanded2');
            filter.append('feFlood')
                .attr('flood-color', '#ffffff')
                .attr('result', 'white');
            filter.append('feComposite')
                .attr('in', 'white')
                .attr('in2', 'expanded2')
                .attr('operator', 'in')
                .attr('result', 'whiteBorder');
            filter.append('feMerge')
                .selectAll('feMergeNode')
                .data(['blackBorder', 'whiteBorder', 'SourceGraphic'])
                .join('feMergeNode')
                .attr('in', d => d);

            // Build nodes and links
            const nodes = Array.from({ length: n }, (_, i) => ({ id: i }));
            const edgeLinks = [];
            const noEdgeLinks = [];

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (matrix[i][j] === 1) {
                        edgeLinks.push({ source: i, target: j, type: 'edge' });
                    } else {
                        noEdgeLinks.push({ source: i, target: j, type: 'noedge' });
                    }
                }
            }

            // Only show edge links in force simulation, but render both
            const allLinks = [...edgeLinks, ...noEdgeLinks];

            if (challengeState.simulation) {
                challengeState.simulation.stop();
            }

            // Adjust force parameters based on node count for better spread
            const linkDistance = Math.max(100, Math.min(200, 800 / Math.sqrt(n)));
            const chargeStrength = Math.max(-400, Math.min(-200, -8000 / n));
            const collisionRadius = Math.max(15, Math.min(25, 400 / n));

            challengeState.simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(edgeLinks).id(d => d.id).distance(linkDistance).strength(0.2))
                .force('charge', d3.forceManyBody().strength(chargeStrength))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(collisionRadius))
                .force('x', d3.forceX(width / 2).strength(0.02))
                .force('y', d3.forceY(height / 2).strength(0.02));

            // Draw no-edge links first (dashed, lighter)
            const noEdgeLine = svg.append('g')
                .selectAll('line.noedge')
                .data(noEdgeLinks)
                .join('line')
                .attr('class', 'challenge-link noedge')
                .attr('stroke', '#00d4ff')
                .attr('stroke-width', 1)
                .attr('stroke-opacity', 0.2)
                .attr('stroke-dasharray', '2,2');

            // Draw edge links
            const edgeLine = svg.append('g')
                .selectAll('line.edge')
                .data(edgeLinks)
                .join('line')
                .attr('class', 'challenge-link edge')
                .attr('stroke', '#ff3366')
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.7);

            // Draw nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('class', 'challenge-node')
                .attr('r', 8)
                .attr('fill', '#e8e8e8')
                .call(drag(challengeState.simulation));

            // Draw labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .attr('class', 'node-label')
                .text(d => d.id);

            challengeState.simulation.on('tick', () => {
                edgeLine
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                noEdgeLine
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 20);
            });

            // Store references for highlighting and clustering
            challengeState.svgElements = { node, edgeLine, noEdgeLine };
            challengeState.canvasSize = { width, height };
            challengeState.nodes = nodes;
        }

        // Update force simulation to cluster nodes by group (clique, indep, other)
        function updateClusteringForces(cliqueSet, indepSet) {
            if (!challengeState.simulation || !challengeState.canvasSize) return;

            const { width, height } = challengeState.canvasSize;
            const nodes = challengeState.nodes;

            // Define cluster centers: clique (left), indep (right), other (center-bottom)
            const cliqueCenterX = width * 0.25;
            const cliqueCenterY = height * 0.4;
            const indepCenterX = width * 0.75;
            const indepCenterY = height * 0.4;
            const otherCenterX = width * 0.5;
            const otherCenterY = height * 0.7;

            // Assign group to each node
            nodes.forEach(node => {
                const inClique = cliqueSet.has(node.id);
                const inIndep = indepSet.has(node.id);
                if (inClique && inIndep) {
                    node.group = 'both';
                    node.targetX = width * 0.5;
                    node.targetY = height * 0.2;
                } else if (inClique) {
                    node.group = 'clique';
                    node.targetX = cliqueCenterX;
                    node.targetY = cliqueCenterY;
                } else if (inIndep) {
                    node.group = 'indep';
                    node.targetX = indepCenterX;
                    node.targetY = indepCenterY;
                } else {
                    node.group = 'other';
                    node.targetX = otherCenterX;
                    node.targetY = otherCenterY;
                }
            });

            // Update forces to pull nodes toward their group centers
            challengeState.simulation
                .force('groupX', d3.forceX(d => d.targetX).strength(0.15))
                .force('groupY', d3.forceY(d => d.targetY).strength(0.15))
                .alpha(0.5)
                .restart();
        }

        // Find all cliques of size k using brute force
        function findCliques(matrix, n, k) {
            const cliques = [];

            function isClique(vertices) {
                for (let i = 0; i < vertices.length; i++) {
                    for (let j = i + 1; j < vertices.length; j++) {
                        if (matrix[vertices[i]][vertices[j]] !== 1) return false;
                    }
                }
                return true;
            }

            function search(start, current) {
                if (current.length === k) {
                    if (isClique(current)) {
                        cliques.push([...current]);
                    }
                    return;
                }

                for (let v = start; v < n; v++) {
                    current.push(v);
                    search(v + 1, current);
                    current.pop();

                    // Limit search for performance
                    if (cliques.length >= 10) return;
                }
            }

            search(0, []);
            return cliques;
        }

        // Find all independent sets of size k
        function findIndependentSets(matrix, n, k) {
            const indeps = [];

            function isIndependent(vertices) {
                for (let i = 0; i < vertices.length; i++) {
                    for (let j = i + 1; j < vertices.length; j++) {
                        if (matrix[vertices[i]][vertices[j]] !== 0) return false;
                    }
                }
                return true;
            }

            function search(start, current) {
                if (current.length === k) {
                    if (isIndependent(current)) {
                        indeps.push([...current]);
                    }
                    return;
                }

                for (let v = start; v < n; v++) {
                    current.push(v);
                    search(v + 1, current);
                    current.pop();

                    // Limit search for performance
                    if (indeps.length >= 10) return;
                }
            }

            search(0, []);
            return indeps;
        }

        // Check for cliques and independent sets
        function checkStructures() {
            const { s, t: tParam, n, adjMatrix } = challengeState;

            const cliques = findCliques(adjMatrix, n, s);
            const indeps = findIndependentSets(adjMatrix, n, tParam);

            challengeState.foundCliques = cliques;
            challengeState.foundIndeps = indeps;

            // Update status indicators
            const cliqueIndicator = document.getElementById('cliqueIndicator');
            const indepIndicator = document.getElementById('indepIndicator');
            const cliqueStatus = document.getElementById('cliqueStatus');
            const indepStatus = document.getElementById('indepStatus');
            const foundStructures = document.getElementById('foundStructures');
            const edgeCountStatus = document.getElementById('edgeCountStatus');

            // Count edges
            let edgeCount = 0;
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (adjMatrix[i][j] === 1) edgeCount++;
                }
            }
            edgeCountStatus.textContent = t('edgeCountLabel', edgeCount);

            // Clique status
            if (cliques.length > 0) {
                cliqueIndicator.className = 'status-indicator warning';
                cliqueStatus.textContent = t('foundClique', s, cliques[0].join(','));
            } else {
                cliqueIndicator.className = 'status-indicator ok';
                cliqueStatus.textContent = t('noClique', s);
            }

            // Independent set status
            if (indeps.length > 0) {
                indepIndicator.className = 'status-indicator warning';
                indepStatus.textContent = t('foundIndep', tParam, indeps[0].join(','));
            } else {
                indepIndicator.className = 'status-indicator ok';
                indepStatus.textContent = t('noIndep', tParam);
            }

            // Show found structures badges
            foundStructures.innerHTML = '';
            if (cliques.length > 0) {
                const badge = document.createElement('span');
                badge.className = 'structure-badge clique';
                badge.textContent = `K${s}: ${cliques.length} found`;
                foundStructures.appendChild(badge);
            }
            if (indeps.length > 0) {
                const badge = document.createElement('span');
                badge.className = 'structure-badge indep';
                badge.textContent = `I${tParam}: ${indeps.length} found`;
                foundStructures.appendChild(badge);
            }

            // Highlight in views
            highlightStructures(cliques, indeps);

            // Check for success (valid Ramsey graph)
            if (cliques.length === 0 && indeps.length === 0) {
                const key = `${Math.min(s,tParam)},${Math.max(s,tParam)}`;
                const bounds = RAMSEY_BOUNDS[key];

                if (bounds && n >= bounds.lower) {
                    // This is a breakthrough!
                    showSuccess(s, tParam, n, bounds.lower, n + 1);
                }
            }
        }

        // Highlight found structures in both views
        function highlightStructures(cliques, indeps) {
            // Clear previous highlights
            document.querySelectorAll('.challenge-matrix-cell.highlight-clique').forEach(el => {
                el.classList.remove('highlight-clique');
            });
            document.querySelectorAll('.challenge-matrix-cell.highlight-indep').forEach(el => {
                el.classList.remove('highlight-indep');
            });
            document.querySelectorAll('.challenge-matrix-cell.highlight-both').forEach(el => {
                el.classList.remove('highlight-both');
            });

            if (challengeState.svgElements) {
                challengeState.svgElements.node
                    .classed('highlight-clique', false)
                    .classed('highlight-indep', false)
                    .classed('highlight-both', false);
                challengeState.svgElements.edgeLine.classed('highlight-clique', false);
                challengeState.svgElements.noEdgeLine.classed('highlight-indep', false);
            }

            // Get sets for intersection detection
            const cliqueSet = cliques.length > 0 ? new Set(cliques[0]) : new Set();
            const indepSet = indeps.length > 0 ? new Set(indeps[0]) : new Set();
            const bothSet = new Set([...cliqueSet].filter(x => indepSet.has(x)));

            // Highlight first clique
            if (cliques.length > 0) {
                const clique = cliques[0];

                // Highlight matrix cells
                clique.forEach(i => {
                    clique.forEach(j => {
                        if (i !== j) {
                            const cell = document.querySelector(`.challenge-matrix-cell[data-i="${i}"][data-j="${j}"]`);
                            if (cell) cell.classList.add('highlight-clique');
                        }
                    });
                });

                // Highlight graph edges
                if (challengeState.svgElements) {
                    challengeState.svgElements.edgeLine.classed('highlight-clique', d =>
                        cliqueSet.has(d.source.id) && cliqueSet.has(d.target.id)
                    );
                }
            }

            // Highlight first independent set
            if (indeps.length > 0) {
                const indep = indeps[0];

                // Highlight matrix cells
                indep.forEach(i => {
                    indep.forEach(j => {
                        if (i !== j) {
                            const cell = document.querySelector(`.challenge-matrix-cell[data-i="${i}"][data-j="${j}"]`);
                            if (cell) {
                                // If already has clique highlight, add both
                                if (cell.classList.contains('highlight-clique')) {
                                    cell.classList.add('highlight-both');
                                } else {
                                    cell.classList.add('highlight-indep');
                                }
                            }
                        }
                    });
                });

                // Highlight graph non-edges
                if (challengeState.svgElements) {
                    challengeState.svgElements.noEdgeLine.classed('highlight-indep', d =>
                        indepSet.has(d.source.id) && indepSet.has(d.target.id)
                    );
                }
            }

            // Highlight graph nodes with proper classes (clique only, indep only, or both)
            if (challengeState.svgElements) {
                challengeState.svgElements.node
                    .classed('highlight-both', d => bothSet.has(d.id))
                    .classed('highlight-clique', d => cliqueSet.has(d.id) && !bothSet.has(d.id))
                    .classed('highlight-indep', d => indepSet.has(d.id) && !bothSet.has(d.id));
            }

            // Update clustering forces to group nodes visually
            updateClusteringForces(cliqueSet, indepSet);
        }

        // Show success celebration
        function showSuccess(sVal, tVal, nVal, oldLower, newLower) {
            const message = document.getElementById('successMessage');
            message.textContent = t('successMsg', sVal, tVal, nVal, oldLower, newLower);
            successOverlay.classList.add('show');
        }

        // Event listeners for challenge mode
        document.getElementById('challengeBtn').addEventListener('click', () => openChallengeMode());
        document.getElementById('closeChallengeBtn').addEventListener('click', closeChallengeMode);
        document.getElementById('startChallengeBtn').addEventListener('click', startChallenge);
        document.getElementById('resetChallengeBtn').addEventListener('click', resetChallenge);
        document.getElementById('importGraphBtn').addEventListener('click', importFromDataset);
        document.getElementById('closeSuccessBtn').addEventListener('click', () => {
            successOverlay.classList.remove('show');
        });

        // Allow clicking on Progress table to start challenge
        function setupProgressTableClick() {
            document.querySelectorAll('.ramsey-table td.range').forEach(cell => {
                cell.style.cursor = 'pointer';
                cell.addEventListener('click', (e) => {
                    const row = e.target.closest('tr');
                    const rowIndex = Array.from(row.parentNode.children).indexOf(row);
                    const cellIndex = Array.from(row.children).indexOf(e.target);

                    if (rowIndex >= 1 && cellIndex >= 1) {
                        const sRow = rowIndex + 1;
                        const tCol = cellIndex;
                        const bounds = RAMSEY_BOUNDS[`${Math.min(sRow,tCol)},${Math.max(sRow,tCol)}`];
                        if (bounds) {
                            closeModal(document.getElementById('progressModal'));
                            openChallengeMode(Math.min(sRow, tCol), Math.max(sRow, tCol), bounds.lower);
                        }
                    }
                });
            });
        }

        // Override the progress modal open to add click handlers
        const originalOpenModal = openModal;
        openModal = function(modalId) {
            originalOpenModal(modalId);
            if (modalId === 'progressModal') {
                setTimeout(setupProgressTableClick, 100);
            }
        };

        // Keyboard shortcut to close challenge mode
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && challengeMode.classList.contains('show')) {
                closeChallengeMode();
            }
        });

        // Initialize challenge selectors
        initChallengeSelectors();

        // Open challenge mode with current graph
        const openChallengeWithGraphBtn = document.getElementById('openChallengeWithGraph');

        function openChallengeWithCurrentGraph() {
            if (graphs.length === 0) return;

            const g = graphs[currentIndex];
            const nNodes = g.nodes;

            // Get s, t from current dataset selection
            const sVal = parseInt(selectS.value) || 5;
            const tVal = parseInt(selectT.value) || 5;

            // Set challenge parameters
            challengeS.value = Math.min(sVal, 6);
            updateChallengeTOptions();
            challengeT.value = Math.min(tVal, 10);
            updateChallengeNOptions();

            // Set n or add 1 for challenge
            const targetN = nNodes + 1;
            if (![...challengeN.options].some(opt => opt.value == targetN)) {
                const option = document.createElement('option');
                option.value = targetN;
                option.textContent = targetN + ' ‚òÖ';
                challengeN.appendChild(option);
            }
            challengeN.value = targetN;

            challengeState.s = parseInt(challengeS.value);
            challengeState.t = parseInt(challengeT.value);
            challengeState.n = targetN;

            // Initialize matrix with current graph edges
            challengeState.adjMatrix = Array.from({ length: targetN }, () => Array(targetN).fill(0));

            for (const [i, j] of g.edges) {
                if (i < targetN && j < targetN) {
                    challengeState.adjMatrix[i][j] = 1;
                    challengeState.adjMatrix[j][i] = 1;
                }
            }

            challengeMode.classList.add('show');
            updateImportOptions();

            // Need to wait for layout to render
            setTimeout(() => {
                renderChallengeViews();
                checkStructures();
            }, 100);
        }

        openChallengeWithGraphBtn.addEventListener('click', openChallengeWithCurrentGraph);

        // Show/hide the "Edit in Challenge" button based on loaded graphs
        function updateChallengeButton() {
            openChallengeWithGraphBtn.style.display = graphs.length > 0 ? 'block' : 'none';
        }

        // Patch parseAndDisplay to update the challenge button
        const originalParseAndDisplay = parseAndDisplay;
        parseAndDisplay = function(text) {
            originalParseAndDisplay(text);
            updateChallengeButton();
        };

        // Init
        initSelectors();
        // Apply saved language
        setLanguage(currentLang);
    </script>
</body>
</html>
